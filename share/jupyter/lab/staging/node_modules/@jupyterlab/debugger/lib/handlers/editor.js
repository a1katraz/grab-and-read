// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { ActivityMonitor } from '@jupyterlab/coreutils';
import { Signal } from '@lumino/signaling';
/**
 * The class name added to the current line.
 */
const LINE_HIGHLIGHT_CLASS = 'jp-DebuggerEditor-highlight';
/**
 * The timeout for listening to editor content changes.
 */
const EDITOR_CHANGED_TIMEOUT = 1000;
/**
 * A handler for a CodeEditor.IEditor.
 */
export class EditorHandler {
    /**
     * Instantiate a new EditorHandler.
     * @param options The instantiation options for a EditorHandler.
     */
    constructor(options) {
        /**
         * Handle a click on the gutter.
         * @param editor The editor from where the click originated.
         * @param lineNumber The line corresponding to the click event.
         */
        this._onGutterClick = (editor, lineNumber) => {
            var _a;
            const info = editor.lineInfo(lineNumber);
            if (!info || this._id !== this._debuggerService.session.connection.id) {
                return;
            }
            const remove = !!info.gutterMarkers;
            let breakpoints = this._getBreakpoints();
            if (remove) {
                breakpoints = breakpoints.filter(ele => ele.line !== info.line + 1);
            }
            else {
                breakpoints.push(Private.createBreakpoint((_a = this._path, (_a !== null && _a !== void 0 ? _a : this._debuggerService.session.connection.name)), info.line + 1));
            }
            void this._debuggerService.updateBreakpoints(this._editor.model.value.text, breakpoints, this._path);
        };
        this._editorMonitor = null;
        this._id = options.debuggerService.session.connection.id;
        this._path = options.path;
        this._debuggerService = options.debuggerService;
        this._editor = options.editor;
        this._onModelChanged();
        this._debuggerService.modelChanged.connect(this._onModelChanged, this);
        this._editorMonitor = new ActivityMonitor({
            signal: this._editor.model.value.changed,
            timeout: EDITOR_CHANGED_TIMEOUT
        });
        this._editorMonitor.activityStopped.connect(() => {
            this._sendEditorBreakpoints();
        }, this);
        this._setupEditor();
    }
    /**
     * Dispose the handler.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._editorMonitor.dispose();
        this._clearEditor();
        this.isDisposed = true;
        Signal.clearData(this);
    }
    /**
     * Handle when the debug model changes.
     */
    _onModelChanged() {
        this._debuggerModel = this._debuggerService.model;
        if (!this._debuggerModel) {
            return;
        }
        this._breakpointsModel = this._debuggerModel.breakpoints;
        this._debuggerModel.callstack.currentFrameChanged.connect(() => {
            EditorHandler.clearHighlight(this._editor);
        });
        this._breakpointsModel.changed.connect(async () => {
            if (!this._editor || this._editor.isDisposed) {
                return;
            }
            this._addBreakpointsToEditor();
        });
        this._breakpointsModel.restored.connect(async () => {
            if (!this._editor || this._editor.isDisposed) {
                return;
            }
            this._addBreakpointsToEditor();
        });
    }
    /**
     * Setup the editor.
     */
    _setupEditor() {
        if (!this._editor || this._editor.isDisposed) {
            return;
        }
        this._addBreakpointsToEditor();
        const editor = this._editor;
        editor.setOption('lineNumbers', true);
        editor.editor.setOption('gutters', [
            'CodeMirror-linenumbers',
            'breakpoints'
        ]);
        editor.editor.on('gutterClick', this._onGutterClick);
    }
    /**
     * Clear the editor by removing visual elements and handlers.
     */
    _clearEditor() {
        if (!this._editor || this._editor.isDisposed) {
            return;
        }
        const editor = this._editor;
        EditorHandler.clearHighlight(editor);
        EditorHandler.clearGutter(editor);
        editor.setOption('lineNumbers', false);
        editor.editor.setOption('gutters', []);
        editor.editor.off('gutterClick', this._onGutterClick);
    }
    /**
     * Send the breakpoints from the editor UI via the debug service.
     */
    _sendEditorBreakpoints() {
        if (this._editor.isDisposed) {
            return;
        }
        const breakpoints = this._getBreakpointsFromEditor().map(lineInfo => {
            return Private.createBreakpoint(this._debuggerService.session.connection.name, lineInfo.line + 1);
        });
        void this._debuggerService.updateBreakpoints(this._editor.model.value.text, breakpoints, this._path);
    }
    /**
     * Add the breakpoints to the editor.
     */
    _addBreakpointsToEditor() {
        const editor = this._editor;
        const breakpoints = this._getBreakpoints();
        if (this._id !== this._debuggerService.session.connection.id) {
            return;
        }
        EditorHandler.clearGutter(editor);
        breakpoints.forEach(breakpoint => {
            editor.editor.setGutterMarker(breakpoint.line - 1, 'breakpoints', Private.createMarkerNode());
        });
    }
    /**
     * Retrieve the breakpoints from the editor.
     */
    _getBreakpointsFromEditor() {
        const editor = this._editor;
        let lines = [];
        for (let i = 0; i < editor.doc.lineCount(); i++) {
            const info = editor.editor.lineInfo(i);
            if (info.gutterMarkers) {
                lines.push(info);
            }
        }
        return lines;
    }
    /**
     * Get the breakpoints for the editor using its content (code),
     * or its path (if it exists).
     */
    _getBreakpoints() {
        var _a;
        const code = this._editor.model.value.text;
        return this._debuggerModel.breakpoints.getBreakpoints((_a = this._path, (_a !== null && _a !== void 0 ? _a : this._debuggerService.getCodeId(code))));
    }
}
/**
 * A namespace for EditorHandler `statics`.
 */
(function (EditorHandler) {
    /**
     * Highlight the current line of the frame in the given editor.
     * @param editor The editor to highlight.
     * @param line The line number.
     */
    function showCurrentLine(editor, line) {
        clearHighlight(editor);
        const cmEditor = editor;
        cmEditor.editor.addLineClass(line - 1, 'wrap', LINE_HIGHLIGHT_CLASS);
    }
    EditorHandler.showCurrentLine = showCurrentLine;
    /**
     * Remove all line highlighting indicators for the given editor.
     * @param editor The editor to cleanup.
     */
    function clearHighlight(editor) {
        if (!editor || editor.isDisposed) {
            return;
        }
        const cmEditor = editor;
        cmEditor.doc.eachLine(line => {
            cmEditor.editor.removeLineClass(line, 'wrap', LINE_HIGHLIGHT_CLASS);
        });
    }
    EditorHandler.clearHighlight = clearHighlight;
    /**
     * Remove line numbers and all gutters from editor.
     * @param editor The editor to cleanup.
     */
    function clearGutter(editor) {
        if (!editor) {
            return;
        }
        const cmEditor = editor;
        cmEditor.doc.eachLine(line => {
            if (line.gutterMarkers) {
                cmEditor.editor.setGutterMarker(line, 'breakpoints', null);
            }
        });
    }
    EditorHandler.clearGutter = clearGutter;
})(EditorHandler || (EditorHandler = {}));
/**
 * A namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Create a marker DOM element for a breakpoint.
     */
    function createMarkerNode() {
        const marker = document.createElement('div');
        marker.className = 'jp-DebuggerEditor-marker';
        marker.innerHTML = '‚óè';
        return marker;
    }
    Private.createMarkerNode = createMarkerNode;
    /**
     *
     * @param session The name of the session.
     * @param line The line number of the breakpoint.
     */
    function createBreakpoint(session, line) {
        return {
            line,
            active: true,
            verified: true,
            source: {
                name: session
            }
        };
    }
    Private.createBreakpoint = createBreakpoint;
})(Private || (Private = {}));
