// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { Signal } from '@lumino/signaling';
import { murmur2 } from 'murmurhash-js';
/**
 * A concrete implementation of IDebugger.
 */
export class DebuggerService {
    /**
     * Instantiate a new DebuggerService.
     */
    constructor() {
        this._isDisposed = false;
        this._sessionChanged = new Signal(this);
        this._modelChanged = new Signal(this);
        this._eventMessage = new Signal(this);
        // Avoids setting session with invalid client
        // session should be set only when a notebook or
        // a console get the focus.
        // TODO: also checks that the notebook or console
        // runs a kernel with debugging ability
        this._session = null;
        // The model will be set by the UI which can be built
        // after the service.
        this._model = null;
    }
    /**
     * Whether the debug service is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Whether the current debugger is started.
     */
    get isStarted() {
        var _a, _b;
        return _b = (_a = this._session) === null || _a === void 0 ? void 0 : _a.isStarted, (_b !== null && _b !== void 0 ? _b : false);
    }
    /**
     * Returns the current debug session.
     */
    get session() {
        return this._session;
    }
    /**
     * Sets the current debug session to the given parameter.
     * @param session - the new debugger session.
     */
    set session(session) {
        var _a;
        if (this._session === session) {
            return;
        }
        if (this._session) {
            this._session.dispose();
        }
        this._session = session;
        (_a = this._session) === null || _a === void 0 ? void 0 : _a.eventMessage.connect((_, event) => {
            if (event.event === 'stopped') {
                this._model.stoppedThreads.add(event.body.threadId);
                void this._getAllFrames();
            }
            else if (event.event === 'continued') {
                this._model.stoppedThreads.delete(event.body.threadId);
                this._clearModel();
                this._clearSignals();
            }
            this._eventMessage.emit(event);
        });
        this._sessionChanged.emit(session);
    }
    /**
     * Returns the debugger model.
     */
    get model() {
        return this._model;
    }
    /**
     * Sets the debugger model to the given parameter.
     * @param model - The new debugger model.
     */
    set model(model) {
        this._model = model;
        this._modelChanged.emit(model);
    }
    /**
     * Signal emitted upon session changed.
     */
    get sessionChanged() {
        return this._sessionChanged;
    }
    /**
     * Signal emitted upon model changed.
     */
    get modelChanged() {
        return this._modelChanged;
    }
    /**
     * Signal emitted for debug event messages.
     */
    get eventMessage() {
        return this._eventMessage;
    }
    /**
     * Request whether debugging is available for the session connection.
     * @param connection The session connection.
     */
    async isAvailable(connection) {
        var _a, _b, _c, _d;
        const kernel = (_a = connection) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel) {
            return false;
        }
        const info = (_b = (await kernel.info), (_b !== null && _b !== void 0 ? _b : null));
        return !!(_d = (_c = info) === null || _c === void 0 ? void 0 : _c.debugger, (_d !== null && _d !== void 0 ? _d : false));
    }
    /**
     * Dispose the debug service.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
    }
    /**
     * Computes an id based on the given code.
     */
    getCodeId(code) {
        return this._tmpFilePrefix + this._hashMethod(code) + this._tmpFileSuffix;
    }
    /**
     * Whether there exists a thread in stopped state.
     */
    hasStoppedThreads() {
        var _a, _b;
        return _b = ((_a = this._model) === null || _a === void 0 ? void 0 : _a.stoppedThreads.size) > 0, (_b !== null && _b !== void 0 ? _b : false);
    }
    /**
     * Starts a debugger.
     * Precondition: !isStarted
     */
    async start() {
        await this.session.start();
    }
    /**
     * Stops the debugger.
     * Precondition: isStarted
     */
    async stop() {
        await this.session.stop();
        if (this._model) {
            this._model.clear();
        }
    }
    /**
     * Restarts the debugger.
     * Precondition: isStarted.
     */
    async restart() {
        const breakpoints = this._model.breakpoints.breakpoints;
        await this.stop();
        await this.start();
        // No need to dump the cells again, we can simply
        // resend the breakpoints to the kernel and update
        // the model.
        for (const [source, bps] of breakpoints) {
            const sourceBreakpoints = Private.toSourceBreakpoints(bps);
            await this._setBreakpoints(sourceBreakpoints, source);
        }
        this._model.breakpoints.restoreBreakpoints(breakpoints);
    }
    /**
     * Restore the state of a debug session.
     * @param autoStart - when true, starts the debugger
     * if it has not been started yet.
     */
    async restoreState(autoStart) {
        var _a, _b;
        if (!this.model || !this.session) {
            return;
        }
        const reply = await this.session.restoreState();
        this._setHashParameters(reply.body.hashMethod, reply.body.hashSeed);
        this._setTmpFileParameters(reply.body.tmpFilePrefix, reply.body.tmpFileSuffix);
        const breakpoints = reply.body.breakpoints;
        let bpMap = new Map();
        if (breakpoints.length !== 0) {
            breakpoints.forEach((bp) => {
                bpMap.set(bp.source, bp.breakpoints.map(breakpoint => {
                    return Object.assign(Object.assign({}, breakpoint), { active: true });
                }));
            });
        }
        const stoppedThreads = new Set(reply.body.stoppedThreads);
        this._model.stoppedThreads = stoppedThreads;
        if (!this.isStarted && (autoStart || stoppedThreads.size !== 0)) {
            await this.start();
        }
        if (this.isStarted || autoStart) {
            this._model.title = this.isStarted ? (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.name : '-';
        }
        this._model.breakpoints.restoreBreakpoints(bpMap);
        if (stoppedThreads.size !== 0) {
            await this._getAllFrames();
        }
        else if (this.isStarted) {
            this._clearModel();
            this._clearSignals();
        }
    }
    /**
     * Continues the execution of the current thread.
     */
    async continue() {
        try {
            await this.session.sendRequest('continue', {
                threadId: this._currentThread()
            });
            this._model.stoppedThreads.delete(this._currentThread());
        }
        catch (err) {
            console.error('Error:', err.message);
        }
    }
    /**
     * Makes the current thread run again for one step.
     */
    async next() {
        try {
            await this.session.sendRequest('next', {
                threadId: this._currentThread()
            });
        }
        catch (err) {
            console.error('Error:', err.message);
        }
    }
    /**
     * Makes the current thread step in a function / method if possible.
     */
    async stepIn() {
        try {
            await this.session.sendRequest('stepIn', {
                threadId: this._currentThread()
            });
        }
        catch (err) {
            console.error('Error:', err.message);
        }
    }
    /**
     * Makes the current thread step out a function / method if possible.
     */
    async stepOut() {
        try {
            await this.session.sendRequest('stepOut', {
                threadId: this._currentThread()
            });
        }
        catch (err) {
            console.error('Error:', err.message);
        }
    }
    /**
     * Update all breakpoints at once.
     * @param code - The code in the cell where the breakpoints are set.
     * @param breakpoints - The list of breakpoints to set.
     * @param path - Optional path to the file where to set the breakpoints.
     */
    async updateBreakpoints(code, breakpoints, path) {
        if (!this.session.isStarted) {
            return;
        }
        if (!path) {
            const dumpedCell = await this.dumpCell(code);
            path = dumpedCell.sourcePath;
        }
        const sourceBreakpoints = Private.toSourceBreakpoints(breakpoints);
        const reply = await this._setBreakpoints(sourceBreakpoints, path);
        let kernelBreakpoints = reply.body.breakpoints.map(breakpoint => {
            return Object.assign(Object.assign({}, breakpoint), { active: true });
        });
        // filter breakpoints with the same line number
        kernelBreakpoints = kernelBreakpoints.filter((breakpoint, i, arr) => arr.findIndex(el => el.line === breakpoint.line) === i);
        this._model.breakpoints.setBreakpoints(path, kernelBreakpoints);
        await this.session.sendRequest('configurationDone', {});
    }
    /**
     * Clear all the breakpoints for the current session.
     */
    async clearBreakpoints() {
        if (!this.session.isStarted) {
            return;
        }
        this._model.breakpoints.breakpoints.forEach(async (breakpoints, path, _) => {
            await this._setBreakpoints([], path);
        });
        let bpMap = new Map();
        this._model.breakpoints.restoreBreakpoints(bpMap);
    }
    /**
     * Retrieve the content of a source file.
     * @param source The source object containing the path to the file.
     */
    async getSource(source) {
        const reply = await this.session.sendRequest('source', {
            source,
            sourceReference: source.sourceReference
        });
        return Object.assign(Object.assign({}, reply.body), { path: source.path });
    }
    /**
     * Dump the content of a cell.
     * @param code The source code to dump.
     */
    async dumpCell(code) {
        const reply = await this.session.sendRequest('dumpCell', { code });
        return reply.body;
    }
    /**
     * Request details for a variable.
     * @param variable The variable for which to request details.
     */
    async getVariableDetails(variablesReference) {
        const reply = await this.session.sendRequest('variables', {
            variablesReference
        });
        return reply.body.variables;
    }
    /**
     * Get all the frames from the kernel.
     */
    async _getAllFrames() {
        this._model.callstack.currentFrameChanged.connect(this._onChangeFrame, this);
        this._model.variables.variableExpanded.connect(this._onVariableExpanded, this);
        const stackFrames = await this._getFrames(this._currentThread());
        this._model.callstack.frames = stackFrames;
    }
    /**
     * Handle a change of the current active frame.
     */
    async _onChangeFrame(_, frame) {
        if (!frame) {
            return;
        }
        const scopes = await this._getScopes(frame);
        const variables = await this._getVariables(scopes[0]);
        const variableScopes = this._convertScopes(scopes, variables);
        this._model.variables.scopes = variableScopes;
    }
    /**
     * Handle a variable expanded event and request variables from the kernel.
     */
    async _onVariableExpanded(_, variable) {
        const reply = await this.session.sendRequest('variables', {
            variablesReference: variable.variablesReference
        });
        let newVariable = Object.assign(Object.assign({}, variable), { expanded: true });
        reply.body.variables.forEach((variable) => {
            newVariable = Object.assign({ [variable.name]: variable }, newVariable);
        });
        const newScopes = this._model.variables.scopes.map(scope => {
            const findIndex = scope.variables.findIndex(ele => ele.variablesReference === variable.variablesReference);
            scope.variables[findIndex] = newVariable;
            return Object.assign({}, scope);
        });
        this._model.variables.scopes = [...newScopes];
        return reply.body.variables;
    }
    /**
     * Get all the frames for the given thread id.
     * @param threadId The thread id.
     */
    async _getFrames(threadId) {
        const reply = await this.session.sendRequest('stackTrace', {
            threadId
        });
        const stackFrames = reply.body.stackFrames;
        return stackFrames;
    }
    /**
     * Get all the scopes for the given frame.
     * @param frame The frame.
     */
    async _getScopes(frame) {
        if (!frame) {
            return;
        }
        const reply = await this.session.sendRequest('scopes', {
            frameId: frame.id
        });
        return reply.body.scopes;
    }
    /**
     * Get the variables for a given scope.
     * @param scopes The scope.
     */
    async _getVariables(scope) {
        if (!scope) {
            return;
        }
        const reply = await this.session.sendRequest('variables', {
            variablesReference: scope.variablesReference
        });
        return reply.body.variables;
    }
    /**
     * Set the breakpoints for a given file.
     * @param breakpoints The list of breakpoints to set.
     * @param path The path to where to set the breakpoints.
     */
    async _setBreakpoints(breakpoints, path) {
        return await this.session.sendRequest('setBreakpoints', {
            breakpoints: breakpoints,
            source: { path },
            sourceModified: false
        });
    }
    /**
     * Map a list of scopes to a list of variables.
     * @param scopes The list of scopes.
     * @param variables The list of variables.
     */
    _convertScopes(scopes, variables) {
        if (!variables || !scopes) {
            return;
        }
        return scopes.map(scope => {
            return {
                name: scope.name,
                variables: variables.map(variable => {
                    return Object.assign({}, variable);
                })
            };
        });
    }
    /**
     * Clear the current model.
     */
    _clearModel() {
        this._model.callstack.frames = [];
        this._model.variables.scopes = [];
    }
    /**
     * Clear the signals set on the model.
     */
    _clearSignals() {
        this._model.callstack.currentFrameChanged.disconnect(this._onChangeFrame, this);
        this._model.variables.variableExpanded.disconnect(this._onVariableExpanded, this);
    }
    /**
     * Get the current thread from the model.
     */
    _currentThread() {
        // TODO: ask the model for the current thread ID
        return 1;
    }
    /**
     * Set the hash parameters for the current session.
     * @param method The hash method.
     * @param seed The seed for the hash method.
     */
    _setHashParameters(method, seed) {
        if (method === 'Murmur2') {
            this._hashMethod = (code) => {
                return murmur2(code, seed).toString();
            };
        }
        else {
            throw new Error('hash method not supported ' + method);
        }
    }
    /**
     * Set the parameters used for the temporary files (e.g. cells).
     * @param prefix The prefix used for the temporary files.
     * @param suffix The suffix used for the temporary files.
     */
    _setTmpFileParameters(prefix, suffix) {
        this._tmpFilePrefix = prefix;
        this._tmpFileSuffix = suffix;
    }
}
/**
 * A namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Convert a list of breakpoints to source breakpoints to be sent to the kernel.
     * @param breakpoints The list of breakpoints.
     */
    function toSourceBreakpoints(breakpoints) {
        return breakpoints.map(breakpoint => {
            return {
                line: breakpoint.line
            };
        });
    }
    Private.toSourceBreakpoints = toSourceBreakpoints;
})(Private || (Private = {}));
