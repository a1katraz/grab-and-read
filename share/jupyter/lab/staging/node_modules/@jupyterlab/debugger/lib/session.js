// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { PromiseDelegate } from '@lumino/coreutils';
import { Signal } from '@lumino/signaling';
/**
 * A concrete implementation of IDebugger.ISession.
 */
export class DebugSession {
    /**
     * Instantiate a new debug session
     *
     * @param options - The debug session instantiation options.
     */
    constructor(options) {
        this._seq = 0;
        this._isDisposed = false;
        this._isStarted = false;
        this._disposed = new Signal(this);
        this._eventMessage = new Signal(this);
        this.connection = options.connection;
    }
    /**
     * Whether the debug session is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * A signal emitted when the debug session is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Returns the API session connection to connect to a debugger.
     */
    get connection() {
        return this._connection;
    }
    /**
     * Sets the API session connection to connect to a debugger to
     * the given parameter.
     *
     * @param connection - The new API session connection.
     */
    set connection(connection) {
        if (this._connection) {
            this._connection.iopubMessage.disconnect(this._handleEvent, this);
        }
        this._connection = connection;
        if (!this._connection) {
            this._isStarted = false;
            return;
        }
        this._connection.iopubMessage.connect(this._handleEvent, this);
    }
    /**
     * Whether the debug session is started
     */
    get isStarted() {
        return this._isStarted;
    }
    /**
     * Signal emitted for debug event messages.
     */
    get eventMessage() {
        return this._eventMessage;
    }
    /**
     * Dispose the debug session.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        Signal.clearData(this);
    }
    /**
     * Start a new debug session
     */
    async start() {
        var _a, _b;
        await this.sendRequest('initialize', {
            clientID: 'jupyterlab',
            clientName: 'JupyterLab',
            adapterID: (_b = (_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.name, (_b !== null && _b !== void 0 ? _b : '')),
            pathFormat: 'path',
            linesStartAt1: true,
            columnsStartAt1: true,
            supportsVariableType: true,
            supportsVariablePaging: true,
            supportsRunInTerminalRequest: true,
            locale: 'en-us'
        });
        this._isStarted = true;
        await this.sendRequest('attach', {});
    }
    /**
     * Stop the running debug session.
     */
    async stop() {
        await this.sendRequest('disconnect', {
            restart: false,
            terminateDebuggee: true
        });
        this._isStarted = false;
    }
    /**
     * Restore the state of a debug session.
     */
    async restoreState() {
        const message = await this.sendRequest('debugInfo', {});
        this._isStarted = message.body.isStarted;
        return message;
    }
    /**
     * Send a custom debug request to the kernel.
     * @param command debug command.
     * @param args arguments for the debug command.
     */
    async sendRequest(command, args) {
        await this._ready();
        const message = await this._sendDebugMessage({
            type: 'request',
            seq: this._seq++,
            command,
            arguments: args
        });
        return message.content;
    }
    /**
     * Handle debug events sent on the 'iopub' channel.
     * @param sender - the emitter of the event.
     * @param message - the event message.
     */
    _handleEvent(sender, message) {
        const msgType = message.header.msg_type;
        if (msgType !== 'debug_event') {
            return;
        }
        const event = message.content;
        this._eventMessage.emit(event);
    }
    /**
     * Send a debug request message to the kernel.
     * @param msg debug request message to send to the kernel.
     */
    async _sendDebugMessage(msg) {
        const kernel = this.connection.kernel;
        if (!kernel) {
            return Promise.reject(new Error('A kernel is required to send debug messages.'));
        }
        const reply = new PromiseDelegate();
        const future = kernel.requestDebug(msg);
        future.onReply = (msg) => {
            return reply.resolve(msg);
        };
        await future.done;
        return reply.promise;
    }
    /**
     * A promise that resolves when the kernel is ready.
     */
    _ready() {
        var _a, _b;
        return (_b = (_a = this._connection) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.info;
    }
}
