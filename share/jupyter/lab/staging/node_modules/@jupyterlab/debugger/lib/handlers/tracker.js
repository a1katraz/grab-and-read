/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
import { DOMUtils, MainAreaWidget, WidgetTracker } from '@jupyterlab/apputils';
import { PathExt } from '@jupyterlab/coreutils';
import { textEditorIcon } from '@jupyterlab/ui-components';
import { chain, each } from '@lumino/algorithm';
import { Token } from '@lumino/coreutils';
import { Signal } from '@lumino/signaling';
import { EditorHandler } from './editor';
import { ReadOnlyEditorFactory } from '../sources/factory';
/**
 * A class which handles notebook, console and editor trackers.
 */
export class TrackerHandler {
    /**
     * Instantiate a new TrackerHandler.
     * @param options The instantiation options for a TrackerHandler.
     */
    constructor(options) {
        this._debuggerService = options.debuggerService;
        this._shell = options.shell;
        this._notebookTracker = options.notebookTracker;
        this._consoleTracker = options.consoleTracker;
        this._editorTracker = options.editorTracker;
        this._readOnlyEditorFactory = new ReadOnlyEditorFactory({
            editorServices: options.editorServices
        });
        this._readOnlyEditorTracker = new WidgetTracker({
            namespace: '@jupyterlab/debugger'
        });
        this._onModelChanged();
        this._debuggerService.modelChanged.connect(this._onModelChanged, this);
    }
    /**
     * Dispose the handler.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        Signal.clearData(this);
    }
    /**
     * Handle when the debug model changes.
     */
    _onModelChanged() {
        this._debuggerModel = this._debuggerService.model;
        if (!this._debuggerModel) {
            return;
        }
        this._debuggerModel.callstack.currentFrameChanged.connect(this._onCurrentFrameChanged, this);
        this._debuggerModel.sources.currentSourceOpened.connect(this._onCurrentSourceOpened, this);
        this._debuggerModel.breakpoints.clicked.connect(async (_, breakpoint) => {
            const path = breakpoint.source.path;
            const source = await this._debuggerService.getSource({
                sourceReference: 0,
                path
            });
            this._onCurrentSourceOpened(null, source);
        });
    }
    /**
     * Handle a current frame changed event.
     * @param _ The sender.
     * @param frame The current frame.
     */
    _onCurrentFrameChanged(_, frame) {
        var _a, _b, _c, _d;
        const debugSessionPath = (_b = (_a = this._debuggerService.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.path;
        const source = (_d = (_c = frame) === null || _c === void 0 ? void 0 : _c.source.path, (_d !== null && _d !== void 0 ? _d : null));
        each(this._find(debugSessionPath, source), editor => {
            requestAnimationFrame(() => {
                EditorHandler.showCurrentLine(editor, frame.line);
            });
        });
    }
    /**
     * Handle a source open event.
     * @param _ The sender.
     * @param source The source to open.
     */
    _onCurrentSourceOpened(_, source) {
        var _a;
        if (!source) {
            return;
        }
        const debugSessionPath = this._debuggerService.session.connection.path;
        const { content, mimeType, path } = source;
        const results = this._find(debugSessionPath, path);
        if (results.next()) {
            return;
        }
        const editorWrapper = this._readOnlyEditorFactory.createNewEditor({
            content,
            mimeType,
            path
        });
        const editor = editorWrapper.editor;
        const editorHandler = new EditorHandler({
            debuggerService: this._debuggerService,
            editor,
            path
        });
        const widget = new MainAreaWidget({
            content: editorWrapper
        });
        widget.id = DOMUtils.createDomID();
        widget.title.label = PathExt.basename(path);
        widget.title.closable = true;
        widget.title.caption = path;
        widget.title.icon = textEditorIcon;
        widget.disposed.connect(() => editorHandler.dispose());
        this._shell.add(widget, 'main');
        void this._readOnlyEditorTracker.add(widget);
        const frame = (_a = this._debuggerModel) === null || _a === void 0 ? void 0 : _a.callstack.frame;
        if (frame) {
            EditorHandler.showCurrentLine(editor, frame.line);
        }
    }
    /**
     * Find the editor for a source matching the current debug session
     * by iterating through all the widgets in each of the notebook,
     * console, file editor, and read-only file editor trackers.
     * @param debugSessionPath The path for the current debug session.
     * @param source The source to find.
     */
    _find(debugSessionPath, source) {
        return chain(this._findInNotebooks(debugSessionPath, source), this._findInConsoles(debugSessionPath, source), this._findInEditors(debugSessionPath, source), this._findInReadOnlyEditors(debugSessionPath, source));
    }
    /**
     * Find the editor for a source matching the current debug session
     * from the notebook tracker.
     * @param debugSessionPath The path for the current debug session.
     * @param source The source to find.
     */
    _findInNotebooks(debugSessionPath, source) {
        if (!this._notebookTracker) {
            return [];
        }
        const editors = [];
        this._notebookTracker.forEach(notebookPanel => {
            const sessionContext = notebookPanel.sessionContext;
            if (sessionContext.path !== debugSessionPath) {
                return;
            }
            const notebook = notebookPanel.content;
            notebook.mode = 'command';
            const cells = notebookPanel.content.widgets;
            cells.forEach((cell, i) => {
                // check the event is for the correct cell
                const code = cell.model.value.text;
                const cellId = this._debuggerService.getCodeId(code);
                if (source !== cellId) {
                    return;
                }
                notebook.activeCellIndex = i;
                const rect = notebook.activeCell.inputArea.node.getBoundingClientRect();
                notebook.scrollToPosition(rect.bottom, 45);
                editors.push(cell.editor);
                this._shell.activateById(notebookPanel.id);
            });
        });
        return editors;
    }
    /**
     * Find the editor for a source matching the current debug session
     * from the console tracker.
     * @param debugSessionPath The path for the current debug session.
     * @param source The source to find.
     */
    _findInConsoles(debugSessionPath, source) {
        if (!this._consoleTracker) {
            return [];
        }
        const editors = [];
        this._consoleTracker.forEach(consoleWidget => {
            const sessionContext = consoleWidget.sessionContext;
            if (sessionContext.path !== debugSessionPath) {
                return;
            }
            const cells = consoleWidget.console.cells;
            each(cells, cell => {
                const code = cell.model.value.text;
                const codeId = this._debuggerService.getCodeId(code);
                if (source !== codeId) {
                    return;
                }
                editors.push(cell.editor);
                this._shell.activateById(consoleWidget.id);
            });
        });
        return editors;
    }
    /**
     * Find the editor for a source matching the current debug session
     * from the editor tracker.
     * @param debugSessionPath The path for the current debug session.
     * @param source The source to find.
     */
    _findInEditors(debugSessionPath, source) {
        if (!this._editorTracker) {
            return;
        }
        const editors = [];
        this._editorTracker.forEach(doc => {
            const fileEditor = doc.content;
            if (debugSessionPath !== fileEditor.context.path) {
                return;
            }
            const editor = fileEditor.editor;
            if (!editor) {
                return;
            }
            const code = editor.model.value.text;
            const codeId = this._debuggerService.getCodeId(code);
            if (source !== codeId) {
                return;
            }
            editors.push(editor);
            this._shell.activateById(doc.id);
        });
        return editors;
    }
    /**
     * Find an editor for a source from the read-only editor tracker.
     * @param source The source to find.
     */
    _findInReadOnlyEditors(_, source) {
        const editors = [];
        this._readOnlyEditorTracker.forEach(widget => {
            var _a;
            const editor = (_a = widget.content) === null || _a === void 0 ? void 0 : _a.editor;
            if (!editor) {
                return;
            }
            const code = editor.model.value.text;
            const codeId = this._debuggerService.getCodeId(code);
            if (widget.title.caption !== source && source !== codeId) {
                return;
            }
            editors.push(editor);
            this._shell.activateById(widget.id);
        });
        return editors;
    }
}
/**
 * A namespace for TrackerHandler statics.
 */
(function (TrackerHandler) {
    /**
     * The Debugger Read Only Editor tracker token.
     * TODO: provide the token for the tracker in the plugin?
     */
    TrackerHandler.IDebuggerReadOnlyEditorTracker = new Token('@jupyterlab/debugger:IDebuggerReadOnlyEditorTracker');
})(TrackerHandler || (TrackerHandler = {}));
