// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { ILabShell, ILayoutRestorer } from '@jupyterlab/application';
import { ICommandPalette, MainAreaWidget, WidgetTracker } from '@jupyterlab/apputils';
import { IEditorServices } from '@jupyterlab/codeeditor';
import { ConsolePanel, IConsoleTracker } from '@jupyterlab/console';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { DocumentWidget } from '@jupyterlab/docregistry';
import { FileEditor, IEditorTracker } from '@jupyterlab/fileeditor';
import { INotebookTracker, NotebookPanel } from '@jupyterlab/notebook';
import { continueIcon, stepIntoIcon, stepOutIcon, stepOverIcon, terminateIcon } from './icons';
import { Debugger } from './debugger';
import { TrackerHandler } from './handlers/tracker';
import { DebuggerService } from './service';
import { DebuggerHandler } from './handler';
import { IDebugger } from './tokens';
import { VariableDetails } from './variables/table';
/**
 * The command IDs used by the debugger plugin.
 */
export var CommandIDs;
(function (CommandIDs) {
    CommandIDs.start = 'debugger:start';
    CommandIDs.stop = 'debugger:stop';
    CommandIDs.debugContinue = 'debugger:continue';
    CommandIDs.terminate = 'debugger:terminate';
    CommandIDs.next = 'debugger:next';
    CommandIDs.stepIn = 'debugger:stepIn';
    CommandIDs.stepOut = 'debugger:stepOut';
    CommandIDs.variableDetails = 'debugger:variable-details';
})(CommandIDs || (CommandIDs = {}));
/**
 * A plugin that provides visual debugging support for consoles.
 */
const consoles = {
    id: '@jupyterlab/debugger:consoles',
    autoStart: true,
    requires: [IDebugger, IConsoleTracker],
    optional: [ILabShell],
    activate: (app, debug, consoleTracker, labShell) => {
        const handler = new DebuggerHandler({
            type: 'console',
            shell: app.shell,
            service: debug
        });
        debug.model.disposed.connect(() => {
            handler.disposeAll(debug);
        });
        const updateHandlerAndCommands = async (widget) => {
            const { sessionContext } = widget;
            await sessionContext.ready;
            await handler.updateContext(widget, sessionContext);
            app.commands.notifyCommandChanged();
        };
        if (labShell) {
            labShell.currentChanged.connect(async (_, update) => {
                const widget = update.newValue;
                if (!(widget instanceof ConsolePanel)) {
                    return;
                }
                await updateHandlerAndCommands(widget);
            });
            return;
        }
        consoleTracker.currentChanged.connect(async (_, consolePanel) => {
            await updateHandlerAndCommands(consolePanel);
        });
    }
};
/**
 * A plugin that provides visual debugging support for file editors.
 */
const files = {
    id: '@jupyterlab/debugger:files',
    autoStart: true,
    requires: [IDebugger, IEditorTracker],
    optional: [ILabShell],
    activate: (app, debug, editorTracker, labShell) => {
        const handler = new DebuggerHandler({
            type: 'file',
            shell: app.shell,
            service: debug
        });
        debug.model.disposed.connect(() => {
            handler.disposeAll(debug);
        });
        const activeSessions = {};
        const updateHandlerAndCommands = async (widget) => {
            const sessions = app.serviceManager.sessions;
            try {
                const model = await sessions.findByPath(widget.context.path);
                let session = activeSessions[model.id];
                if (!session) {
                    // Use `connectTo` only if the session does not exist.
                    // `connectTo` sends a kernel_info_request on the shell
                    // channel, which blocks the debug session restore when waiting
                    // for the kernel to be ready
                    session = sessions.connectTo({ model });
                    activeSessions[model.id] = session;
                }
                await handler.update(widget, session);
                app.commands.notifyCommandChanged();
            }
            catch (_a) {
                return;
            }
        };
        if (labShell) {
            labShell.currentChanged.connect(async (_, update) => {
                const widget = update.newValue;
                if (!(widget instanceof DocumentWidget)) {
                    return;
                }
                const content = widget.content;
                if (!(content instanceof FileEditor)) {
                    return;
                }
                await updateHandlerAndCommands(widget);
            });
        }
        editorTracker.currentChanged.connect(async (_, documentWidget) => {
            await updateHandlerAndCommands(documentWidget);
        });
    }
};
/**
 * A plugin that provides visual debugging support for notebooks.
 */
const notebooks = {
    id: '@jupyterlab/debugger:notebooks',
    autoStart: true,
    requires: [IDebugger, INotebookTracker],
    optional: [ILabShell],
    activate: (app, debug, notebookTracker, labShell) => {
        const handler = new DebuggerHandler({
            type: 'notebook',
            shell: app.shell,
            service: debug
        });
        debug.model.disposed.connect(() => {
            handler.disposeAll(debug);
        });
        const updateHandlerAndCommands = async (widget) => {
            const { sessionContext } = widget;
            await sessionContext.ready;
            await handler.updateContext(widget, sessionContext);
            app.commands.notifyCommandChanged();
        };
        if (labShell) {
            labShell.currentChanged.connect(async (_, update) => {
                const widget = update.newValue;
                if (!(widget instanceof NotebookPanel)) {
                    return;
                }
                await updateHandlerAndCommands(widget);
            });
            return;
        }
        notebookTracker.currentChanged.connect(async (_, notebookPanel) => {
            await updateHandlerAndCommands(notebookPanel);
        });
    }
};
/**
 * A plugin that tracks notebook, console and file editors used for debugging.
 */
const tracker = {
    id: '@jupyterlab/debugger:tracker',
    autoStart: true,
    requires: [IDebugger, IEditorServices],
    optional: [INotebookTracker, IConsoleTracker, IEditorTracker],
    activate: (app, debug, editorServices, notebookTracker, consoleTracker, editorTracker) => {
        new TrackerHandler({
            shell: app.shell,
            editorServices,
            debuggerService: debug,
            notebookTracker,
            consoleTracker,
            editorTracker
        });
    }
};
/*
 * A plugin to open detailed views for variables.
 */
const variables = {
    id: '@jupyterlab/debugger:variables',
    autoStart: true,
    requires: [IDebugger],
    activate: (app, service) => {
        const { commands, shell } = app;
        const tracker = new WidgetTracker({
            namespace: 'variableDetails'
        });
        commands.addCommand(CommandIDs.variableDetails, {
            label: 'Variable Details',
            caption: 'Variable Details',
            execute: async (args) => {
                const { variableReference } = args;
                if (!variableReference || variableReference === 0) {
                    return;
                }
                const details = await service.getVariableDetails(variableReference);
                const title = args.title;
                const id = `jp-debugger-details-${title}`;
                if (!details ||
                    details.length === 0 ||
                    tracker.find(widget => widget.id === id)) {
                    return;
                }
                const model = service.model.variables;
                const widget = new MainAreaWidget({
                    content: new VariableDetails({
                        commands,
                        service,
                        details,
                        model,
                        title
                    })
                });
                widget.id = id;
                void tracker.add(widget);
                shell.add(widget, 'main', {
                    mode: tracker.currentWidget ? 'split-right' : 'split-bottom'
                });
            }
        });
    }
};
/**
 * A plugin providing a tracker code debuggers.
 */
const main = {
    id: '@jupyterlab/debugger:main',
    requires: [IEditorServices],
    optional: [ILayoutRestorer, ICommandPalette, ISettingRegistry],
    provides: IDebugger,
    autoStart: true,
    activate: async (app, editorServices, restorer, palette, settingRegistry) => {
        const { commands, shell } = app;
        const service = new DebuggerService();
        commands.addCommand(CommandIDs.debugContinue, {
            label: 'Continue',
            caption: 'Continue',
            icon: continueIcon,
            isEnabled: () => {
                return service.hasStoppedThreads();
            },
            execute: async () => {
                await service.continue();
                commands.notifyCommandChanged();
            }
        });
        commands.addCommand(CommandIDs.terminate, {
            label: 'Terminate',
            caption: 'Terminate',
            icon: terminateIcon,
            isEnabled: () => {
                return service.hasStoppedThreads();
            },
            execute: async () => {
                await service.restart();
                commands.notifyCommandChanged();
            }
        });
        commands.addCommand(CommandIDs.next, {
            label: 'Next',
            caption: 'Next',
            icon: stepOverIcon,
            isEnabled: () => {
                return service.hasStoppedThreads();
            },
            execute: async () => {
                await service.next();
            }
        });
        commands.addCommand(CommandIDs.stepIn, {
            label: 'StepIn',
            caption: 'Step In',
            icon: stepIntoIcon,
            isEnabled: () => {
                return service.hasStoppedThreads();
            },
            execute: async () => {
                await service.stepIn();
            }
        });
        commands.addCommand(CommandIDs.stepOut, {
            label: 'StepOut',
            caption: 'Step Out',
            icon: stepOutIcon,
            isEnabled: () => {
                return service.hasStoppedThreads();
            },
            execute: async () => {
                await service.stepOut();
            }
        });
        const callstackCommands = {
            registry: commands,
            continue: CommandIDs.debugContinue,
            terminate: CommandIDs.terminate,
            next: CommandIDs.next,
            stepIn: CommandIDs.stepIn,
            stepOut: CommandIDs.stepOut
        };
        const sidebar = new Debugger.Sidebar({
            service,
            callstackCommands,
            editorServices
        });
        if (settingRegistry) {
            const setting = await settingRegistry.load(main.id);
            const updateVariableSettings = () => {
                var _a, _b, _c;
                const filters = setting.get('variableFilters').composite;
                const kernelName = (_c = (_b = (_a = service.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name;
                const list = filters[kernelName];
                if (!list) {
                    return;
                }
                sidebar.variables.filter = new Set(list);
            };
            updateVariableSettings();
            setting.changed.connect(updateVariableSettings);
            sidebar.service.sessionChanged.connect(updateVariableSettings);
        }
        sidebar.service.eventMessage.connect(_ => {
            commands.notifyCommandChanged();
        });
        sidebar.service.sessionChanged.connect(_ => {
            commands.notifyCommandChanged();
        });
        if (restorer) {
            restorer.add(sidebar, 'debugger-sidebar');
        }
        shell.add(sidebar, 'right');
        if (palette) {
            const category = 'Debugger';
            [
                CommandIDs.debugContinue,
                CommandIDs.terminate,
                CommandIDs.next,
                CommandIDs.stepIn,
                CommandIDs.stepOut
            ].forEach(command => {
                palette.addItem({ command, category });
            });
        }
        return service;
    }
};
/**
 * Export the plugins as default.
 */
const plugins = [
    consoles,
    files,
    notebooks,
    tracker,
    variables,
    main
];
export default plugins;
